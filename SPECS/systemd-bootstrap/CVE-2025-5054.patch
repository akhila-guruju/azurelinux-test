From 6709e861a365ac88a29675ae28bddd246f536a46 Mon Sep 17 00:00:00 2001
From: akhila-guruju <v-guakhila@microsoft.com>
Date: Wed, 18 Jun 2025 11:22:48 +0000
Subject: [PATCH] Address CVE-2025-5054

Upstream patch Reference: https://github.com/systemd/systemd/pull/37125/commits/fc7943166962b78ebf61b5507f63f4212f3d341a

---
 man/systemd-coredump.xml     |  11 ++++
 man/version-info.xml         |  87 +++++++++++++++++++++++++
 src/coredump/coredump.c      | 120 ++++++++++++++++++++++++++---------
 sysctl.d/50-coredump.conf.in |   2 +-
 4 files changed, 188 insertions(+), 32 deletions(-)
 create mode 100644 man/version-info.xml

diff --git a/man/systemd-coredump.xml b/man/systemd-coredump.xml
index cb9f477..e49b180 100644
--- a/man/systemd-coredump.xml
+++ b/man/systemd-coredump.xml
@@ -186,6 +186,17 @@ COREDUMP_FILENAME=/var/lib/systemd/coredump/core.Web….552351.….zst
         </listitem>
       </varlistentry>
 
+      <varlistentry>
+        <term><varname>COREDUMP_BY_PIDFD=</varname></term>
+        <listitem><para>If the crashed process was analyzed using a PIDFD provided by the kernel (requires
+        kernel v6.16) then this field will be present and set to <literal>1</literal>. If this field is
+        not set, then the crashed process was analyzed via a PID, which is known to be subject to race
+        conditions.</para>
+
+        <xi:include href="version-info.xml" xpointer="v258"/>
+        </listitem>
+      </varlistentry>
+
       <varlistentry>
         <term><varname>COREDUMP_TIMESTAMP=</varname></term>
         <listitem><para>The time of the crash as reported by the kernel (in µs since the epoch).</para>
diff --git a/man/version-info.xml b/man/version-info.xml
new file mode 100644
index 0000000..54440fe
--- /dev/null
+++ b/man/version-info.xml
@@ -0,0 +1,87 @@
+<?xml version="1.0"?>
+<!DOCTYPE refsect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
+  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
+<!-- SPDX-License-Identifier: LGPL-2.1-or-later -->
+
+<refsect1>
+  <title/>
+
+  <para id="v183">Added in version 183.</para>
+  <para id="v184">Added in version 184.</para>
+  <para id="v185">Added in version 185.</para>
+  <para id="v186">Added in version 186.</para>
+  <para id="v187">Added in version 187.</para>
+  <para id="v188">Added in version 188.</para>
+  <para id="v189">Added in version 189.</para>
+  <para id="v190">Added in version 190.</para>
+  <para id="v191">Added in version 191.</para>
+  <para id="v192">Added in version 192.</para>
+  <para id="v193">Added in version 193.</para>
+  <para id="v194">Added in version 194.</para>
+  <para id="v195">Added in version 195.</para>
+  <para id="v196">Added in version 196.</para>
+  <para id="v197">Added in version 197.</para>
+  <para id="v198">Added in version 198.</para>
+  <para id="v199">Added in version 199.</para>
+  <para id="v200">Added in version 200.</para>
+  <para id="v201">Added in version 201.</para>
+  <para id="v202">Added in version 202.</para>
+  <para id="v203">Added in version 203.</para>
+  <para id="v204">Added in version 204.</para>
+  <para id="v205">Added in version 205.</para>
+  <para id="v206">Added in version 206.</para>
+  <para id="v207">Added in version 207.</para>
+  <para id="v208">Added in version 208.</para>
+  <para id="v209">Added in version 209.</para>
+  <para id="v210">Added in version 210.</para>
+  <para id="v211">Added in version 211.</para>
+  <para id="v212">Added in version 212.</para>
+  <para id="v213">Added in version 213.</para>
+  <para id="v214">Added in version 214.</para>
+  <para id="v215">Added in version 215.</para>
+  <para id="v216">Added in version 216.</para>
+  <para id="v217">Added in version 217.</para>
+  <para id="v218">Added in version 218.</para>
+  <para id="v219">Added in version 219.</para>
+  <para id="v220">Added in version 220.</para>
+  <para id="v221">Added in version 221.</para>
+  <para id="v222">Added in version 222.</para>
+  <para id="v223">Added in version 223.</para>
+  <para id="v224">Added in version 224.</para>
+  <para id="v225">Added in version 225.</para>
+  <para id="v226">Added in version 226.</para>
+  <para id="v227">Added in version 227.</para>
+  <para id="v228">Added in version 228.</para>
+  <para id="v229">Added in version 229.</para>
+  <para id="v230">Added in version 230.</para>
+  <para id="v231">Added in version 231.</para>
+  <para id="v232">Added in version 232.</para>
+  <para id="v233">Added in version 233.</para>
+  <para id="v234">Added in version 234.</para>
+  <para id="v235">Added in version 235.</para>
+  <para id="v236">Added in version 236.</para>
+  <para id="v237">Added in version 237.</para>
+  <para id="v238">Added in version 238.</para>
+  <para id="v239">Added in version 239.</para>
+  <para id="v240">Added in version 240.</para>
+  <para id="v241">Added in version 241.</para>
+  <para id="v242">Added in version 242.</para>
+  <para id="v243">Added in version 243.</para>
+  <para id="v244">Added in version 244.</para>
+  <para id="v245">Added in version 245.</para>
+  <para id="v246">Added in version 246.</para>
+  <para id="v247">Added in version 247.</para>
+  <para id="v248">Added in version 248.</para>
+  <para id="v249">Added in version 249.</para>
+  <para id="v250">Added in version 250.</para>
+  <para id="v251">Added in version 251.</para>
+  <para id="v252">Added in version 252.</para>
+  <para id="v253">Added in version 253.</para>
+  <para id="v254">Added in version 254.</para>
+  <para id="v255">Added in version 255.</para>
+  <para id="v256">Added in version 256.</para>
+  <para id="v257">Added in version 257.</para>
+  <para id="v258">Added in version 258.</para>
+  <para id="v259">Added in version 259.</para>
+  <para id="v260">Added in version 260.</para>
+</refsect1>
diff --git a/src/coredump/coredump.c b/src/coredump/coredump.c
index 060a1b0..302bc2c 100644
--- a/src/coredump/coredump.c
+++ b/src/coredump/coredump.c
@@ -85,6 +85,13 @@ enum {
         META_ARGV_TIMESTAMP,    /* %t: time of dump, expressed as seconds since the Epoch (we expand this to µs granularity) */
         META_ARGV_RLIMIT,       /* %c: core file size soft resource limit */
         META_ARGV_HOSTNAME,     /* %h: hostname */
+        _META_ARGV_REQUIRED_MAX,
+        /* This counter includes META_COMM but excludes META_ARGV_PIDFD, as it's forwarded to foreign
+         * coredump that only knows about the existing mandatory arguments */
+        _META_MANDATORY_MAX = _META_ARGV_REQUIRED_MAX,
+        /* The following argvs are only available with new kernels, so they are optional */
+        META_ARGV_PIDFD = _META_ARGV_REQUIRED_MAX, /* %F: pidfd of the process, since v6.16 */
+         _META_ARGV_MAX,
         _META_ARGV_MAX,
 
         /* The following indexes are cached for a couple of special fields we use (and
@@ -93,12 +100,11 @@ enum {
          * environment. */
 
         META_COMM = _META_ARGV_MAX,
-        _META_MANDATORY_MAX,
 
         /* The rest are similar to the previous ones except that we won't fail if one of
          * them is missing. */
 
-        META_EXE = _META_MANDATORY_MAX,
+        META_EXE,
         META_UNIT,
         META_PROC_AUXV,
         _META_MAX
@@ -112,6 +118,7 @@ static const char * const meta_field_names[_META_MAX] = {
         [META_ARGV_TIMESTAMP]    = "COREDUMP_TIMESTAMP=",
         [META_ARGV_RLIMIT]       = "COREDUMP_RLIMIT=",
         [META_ARGV_HOSTNAME]     = "COREDUMP_HOSTNAME=",
+        [META_ARGV_PIDFD]        = "COREDUMP_BY_PIDFD=",
         [META_COMM]              = "COREDUMP_COMM=",
         [META_EXE]               = "COREDUMP_EXE=",
         [META_UNIT]              = "COREDUMP_UNIT=",
@@ -121,8 +128,10 @@ static const char * const meta_field_names[_META_MAX] = {
 typedef struct Context {
         const char *meta[_META_MAX];
         size_t meta_size[_META_MAX];
+        PidRef pidref;
         pid_t pid;
         bool is_pid1;
+        bool got_pidfd;
         bool is_journald;
 } Context;
 
@@ -1069,7 +1078,7 @@ static int save_context(Context *context, const struct iovec_wrapper *iovw) {
 
         assert(context);
         assert(iovw);
-        assert(iovw->count >= _META_ARGV_MAX);
+        assert(iovw->count >= _META_ARGV_REQUIRED_MAX);
 
         /* The context does not allocate any memory on its own */
 
@@ -1092,9 +1101,9 @@ static int save_context(Context *context, const struct iovec_wrapper *iovw) {
                 }
         }
 
-        if (!context->meta[META_ARGV_PID])
-                return log_error_errno(SYNTHETIC_ERRNO(EINVAL),
-                                       "Failed to find the PID of crashing process");
+        for (int i = 0; i < _META_ARGV_REQUIRED_MAX; i++)
+                if (!context->meta[i])
+                        return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "A required (%s) has not been sent, aborting.", meta_field_names[i]);
 
         r = parse_pid(context->meta[META_ARGV_PID], &context->pid);
         if (r < 0)
@@ -1274,43 +1283,80 @@ static int gather_pid_metadata_from_argv(
                 Context *context,
                 int argc, char **argv) {
 
-        _cleanup_free_ char *free_timestamp = NULL;
-        int r, signo;
-        char *t;
+        _cleanup_(pidref_done) PidRef local_pidref = PIDREF_NULL;
+        int r, kernel_fd = -EBADF;
+
+        assert(iovw);
+        assert(context);
 
         /* We gather all metadata that were passed via argv[] into an array of iovecs that
-         * we'll forward to the socket unit */
+         * we'll forward to the socket unit.
+         *
+         * We require at least _META_ARGV_REQUIRED args, but will accept more.
+         * We know how to parse _META_ARGV_MAX args. The rest will be ignored. */
 
-        if (argc < _META_ARGV_MAX)
+        if (argc < _META_ARGV_REQUIRED_MAX)
                 return log_error_errno(SYNTHETIC_ERRNO(EINVAL),
                                        "Not enough arguments passed by the kernel (%i, expected %i).",
-                                       argc, _META_ARGV_MAX);
-
-        for (int i = 0; i < _META_ARGV_MAX; i++) {
-
-                t = argv[i];
+                                       argc, _META_ARGV_REQUIRED_MAX);
 
-                switch (i) {
+        for (int i = 0; i < MIN(argc, _META_ARGV_MAX); i++) {
+                _cleanup_free_ char *buf = NULL;
+                const char *t = argv[i];
 
-                case META_ARGV_TIMESTAMP:
+                if (i == META_ARGV_TIMESTAMP) {
                         /* The journal fields contain the timestamp padded with six
                          * zeroes, so that the kernel-supplied 1s granularity timestamps
-                         * becomes 1µs granularity, i.e. the granularity systemd usually
+                         * becomes 1μs granularity, i.e. the granularity systemd usually
                          * operates in. */
-                        t = free_timestamp = strjoin(argv[i], "000000");
-                        if (!t)
+                        buf = strjoin(argv[i], "000000");
+                        if (!buf)
                                 return log_oom();
-                        break;
 
-                case META_ARGV_SIGNAL:
-                        /* For signal, record its pretty name too */
-                        if (safe_atoi(argv[i], &signo) >= 0 && SIGNAL_VALID(signo))
-                                (void) iovw_put_string_field(iovw, "COREDUMP_SIGNAL_NAME=SIG",
-                                                             signal_to_string(signo));
-                        break;
+                        t = buf;
+                }
 
-                default:
-                        break;
+                if (i == META_ARGV_PID) {
+                        /* Store this so that we can check whether the core will be forwarded to a container
+                         * even when the kernel doesn't provide a pidfd. Can be dropped once baseline is
+                         * >= v6.16. */
+                        r = pidref_set_pidstr(&local_pidref, t);
+                        if (r < 0)
+                                return log_error_errno(r, "Failed to initialize pidref from pid %s: %m", t);
+                }
+
+                if (i == META_ARGV_PIDFD) {
+                        /* If the current kernel doesn't support the %F specifier (which resolves to a
+                         * pidfd), but we included it in the core_pattern expression, we'll receive an empty
+                         * string here. Deal with that gracefully. */
+                        if (isempty(t))
+                                continue;
+
+                        assert(!pidref_is_set(&context->pidref));
+                        assert(kernel_fd < 0);
+
+                        kernel_fd = parse_fd(t);
+                        if (kernel_fd < 0)
+                                return log_error_errno(kernel_fd, "Failed to parse pidfd \"%s\": %m", t);
+
+                        r = pidref_set_pidfd(&context->pidref, kernel_fd);
+                        if (r < 0)
+                                return log_error_errno(r, "Failed to initialize pidref from pidfd %d: %m", kernel_fd);
+
+                        context->got_pidfd = 1;
+
+                        /* If there are containers involved with different versions of the code they might
+                         * not be using pidfds, so it would be wrong to set the metadata, skip it. */
+                        r = in_same_namespace(/* pid1 = */ 0, context->pidref.pid, NAMESPACE_PID);
+                        if (r < 0)
+                                log_debug_errno(r, "Failed to check pidns of crashing process, ignoring: %m");
+                        if (r <= 0)
+                                continue;
+
+                        /* We don't print the fd number in the journal as it's meaningless, but we still
+                         * record that the parsing was done with a kernel-provided fd as it means it's safe
+                         * from races, which is valuable information to provide in the journal record. */
+                        t = "1";
                 }
 
                 r = iovw_put_string_field(iovw, meta_field_names[i], t);
@@ -1320,7 +1366,19 @@ static int gather_pid_metadata_from_argv(
 
         /* Cache some of the process metadata we collected so far and that we'll need to
          * access soon */
-        return save_context(context, iovw);
+        r = save_context(context, iovw);
+        if (r < 0)
+                return r;
+
+        /* If the kernel didn't give us a PIDFD, then use the one derived from the
+         * PID immediately, given we have it. */
+        if (!pidref_is_set(&context->pidref))
+                context->pidref = TAKE_PIDREF(local_pidref);
+
+        /* Close the kernel-provided FD as the last thing after everything else succeeded */
+        kernel_fd = safe_close(kernel_fd);
+
+        return 0;
 }
 
 static int gather_pid_metadata(struct iovec_wrapper *iovw, Context *context) {
diff --git a/sysctl.d/50-coredump.conf.in b/sysctl.d/50-coredump.conf.in
index 5fb551a..46dc364 100644
--- a/sysctl.d/50-coredump.conf.in
+++ b/sysctl.d/50-coredump.conf.in
@@ -13,7 +13,7 @@
 # the core dump.
 #
 # See systemd-coredump(8) and core(5).
-kernel.core_pattern=|{{ROOTLIBEXECDIR}}/systemd-coredump %P %u %g %s %t %c %h
+kernel.core_pattern=|{{ROOTLIBEXECDIR}}/systemd-coredump %P %u %g %s %t %c %h %F
 
 # Allow 16 coredumps to be dispatched in parallel by the kernel.
 # We collect metadata from /proc/%P/, and thus need to make sure the crashed
-- 
2.45.2

